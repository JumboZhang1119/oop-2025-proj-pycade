# Pycade Bomber (瘋狂炸彈人 Pygame 複刻版)

https://hackmd.io/@peienwu/SJr3Yhd-gl

本專案是物件導向程式設計 (OOP) 課程專案 (oop-2025-proj-pycade)，旨在使用 Pygame 函式庫複刻經典遊戲《瘋狂炸彈人》(Crazy Arcade/Bomberman)。目前的開發目標是完成一個功能相對完善、包含單人對戰 AI 的本地端可執行版本，並為未來可能的擴展（如更複雜的 AI 演算法、強化學習訓練、使用 Pygbag 進行網頁化部署）打下良好基礎。

## 目錄

- [Pycade Bomber (瘋狂炸彈人 Pygame 複刻版)](#pycade-bomber-瘋狂炸彈人-pygame-複刻版)
  - [目錄](#目錄)
  - [目前狀態與版本資訊](#目前狀態與版本資訊)
  - [環境設定與執行](#環境設定與執行)
    - [前置需求](#前置需求)
    - [安裝依賴](#安裝依賴)
    - [執行遊戲](#執行遊戲)
  - [遊戲控制](#遊戲控制)
  - [專案架構](#專案架構)
  - [後續優化與開發方向 (致組員)](#後續優化與開發方向-致組員)
    - [優先任務：提升 AI 智慧與遊戲性](#優先任務提升-ai-智慧與遊戲性)
    - [遊戲體驗與功能擴充](#遊戲體驗與功能擴充)
    - [程式碼與專案管理](#程式碼與專案管理)
    - [長期目標思考](#長期目標思考)

## 目前狀態與版本資訊

* **專案版本 (Tag 建議)**：`v0.3.0-discrete-movement` (表示已實現瞬時格子移動的核心功能)
* **核心功能實現**：
    * 玩家角色 (人類與AI) 採用**瞬時格子移動**系統，位置離散化。
    * 人類玩家可透過鍵盤控制移動（按住方向鍵可持續移動，一格接一格，有動作動畫）。
    * AI 玩家由 `AIController` 控制，基於路徑進行格子移動。
    * 基本的炸彈放置機制。
    * 炸彈爆炸產生火焰，可摧毀可破壞的牆壁。
    * 基本的道具系統 (分數、生命、炸彈容量、炸彈威力)，道具由牆壁被炸毀時隨機掉落。
    * 隨機地圖生成，包含不可破壞的固定牆壁和可隨機分佈的可破壞牆壁，並設有玩家初始安全區。
    * 初步的 AI 對手，基於有限狀態機 (FSM) 和廣度優先搜索 (BFS) 進行決策（例如，追逐玩家、撿道具、初步的炸牆意圖）。
    * 遊戲界面 HUD 可顯示玩家的基本狀態資訊（生命、炸彈、威力、分數）。
    * 基本的遊戲流程控制，包括遊戲結束判斷與重新開始功能。
    * 玩家和 AI 會受到爆炸傷害。
    * 玩家（包括AI）無法直接穿過已放置的炸彈（炸彈被視為臨時障礙物，但允許剛放置炸彈的玩家離開該格）。

* **已知主要待辦事項 / 問題點**：
    * **AI 行為**：
        * AI 對於「放置炸彈開路」的策略執行尚不穩定或過於保守。根據最新日誌，AI 雖然能判斷可以安全放置炸彈並找到逃生路線 (`can_place_bomb_safely_at` 返回 `True`，`find_strategic_wall_to_bomb` 返回有效計畫），但實際放置炸彈的行為仍未穩定出現，需要進一步確認從決策到執行的完整鏈路是否通暢，特別是 `handle_strategic_bombing_for_path_state` 中的最終放置條件。
        * AI 的整體「智慧感」、 situational awareness (情境感知) 和行為多樣性有很大的提升空間。
        * AI 在複雜危險環境下的逃生路徑選擇及執行可能不夠完美。
    * **人類玩家體驗**：
        * 持續按鍵移動的「手感」（例如，`Player.ACTION_ANIMATION_DURATION` 的值）可能需要進一步微調以達到最佳體驗。
    * **遊戲內容**：
        * 道具效果 `apply_effect` 在 `Item` 基類中的日誌提示未完全為每個子類實現（`Item of type '...' collected by player, but apply_effect not implemented for base Item.`）。實際上各道具子類已實現各自的 `apply_effect`，但可能是在呼叫 `super().apply_effect(player)` 時觸發了基類的 `print`。需檢視並修正此日誌輸出。
    * **程式碼與資源**：
        * 部分資源檔案路徑可能使用了預留位置 (placeholder)。
        * 音效部分尚未整合。

## 環境設定與執行

### 前置需求

* Python 3.x (建議 3.8 或更高版本)
* pip (Python 套件安裝器)
* Git (用於版本控制與協作)

### 安裝依賴

1.  使用 Git 克隆 (Clone) 此專案到您的本地電腦：
    ```bash
    git clone <repository_url>
    cd oop-2025-proj-pycade
    ```
2.  (強烈建議) 在專案目錄下建立並啟用一個 Python 虛擬環境，以隔離專案依賴：
    ```bash
    python -m venv venv
    # Windows:
    # venv\Scripts\activate
    # Linux/macOS:
    # source venv/bin/activate
    ```
3.  安裝必要的 Python 套件：
    ```bash
    pip install -r requirements.txt
    ```
    (如果 `requirements.txt` 尚未建立，請先在啟用了虛擬環境的專案根目錄下執行 `pip freeze > requirements.txt` 來生成它，主要依賴應為 `pygame`)

### 執行遊戲

在專案根目錄下，使用 Python 直譯器執行 `main.py`：
```bash
python3 main.py
```
## 遊戲控制

* **人類玩家 (Player 1)**：
    * **移動**：方向鍵 (上、下、左、右) 或 W、A、S、D 鍵。按住可持續一格格移動。
    * **放置炸彈**：F 鍵。
* **遊戲通用**：
    * **退出遊戲**：ESC 鍵。
    * **重新開始** (遊戲結束後)：R 鍵。

## 專案架構

本專案採用模組化的結構，主要包含以下幾個部分：

* **`main.py`**: 遊戲的入口點，初始化 Pygame、創建 `Game` 物件並開始遊戲主循環。
* **`settings.py`**: 存放遊戲的全域設定，如螢幕尺寸、幀率、顏色定義、圖片與資源路徑、遊戲機制參數（例如炸彈威力、玩家動作持續時間、AI決策間隔等）。便於統一管理和調整遊戲數值。
* **`game.py`**: 包含核心的 `Game` 類別。
    * 負責管理遊戲的主循環 (`run` 方法)。
    * 處理遊戲事件 (`events` 方法)，如鍵盤輸入（目前主要用於放置炸彈、ESC、重新開始）、關閉視窗。
    * 更新遊戲狀態 (`update` 方法)，包括所有精靈的更新（玩家移動由其自身 `update` 和 `get_input` 處理）、碰撞檢測（爆炸與角色/牆壁、角色與道具）、遊戲邏輯判斷（如遊戲結束）。
    * 繪製遊戲畫面 (`draw` 方法)，將所有可見元素渲染到螢幕上。
    * 管理遊戲中的各類精靈群組 (`pygame.sprite.Group`)，例如 `all_sprites`, `players_group`, `bombs_group`, `items_group`, `solid_obstacles_group`。
    * 初始化並管理 `MapManager` 和 `AIController`。
* **`core/` 目錄**: 包含遊戲的核心機制和管理器。
    * `__init__.py`
    * `ai_controller.py` (`AIController` 類別): 實現 AI 玩家的決策邏輯。基於有限狀態機 (FSM) 設計，包含多種狀態 (如巡邏、追擊、逃跑、撿道具、炸牆)。使用廣度優先搜索 (BFS) 進行路徑規劃（基於格子），並包含複雜的危險評估和安全判斷邏輯。AI 的移動請求是向其控制的 `Player` 物件發出 `attempt_move_to_tile` 指令。
    * `map_manager.py` (`MapManager` 類別): 負責地圖的載入、生成（包括隨機佈置可破壞牆壁，並考慮玩家初始安全區）、以及提供地圖資訊查詢（如某格子是否可走、是否為固定牆）。
* **`sprites/` 目錄**: 包含遊戲中所有可見或可互動的物件（精靈）的類別定義。所有精靈都繼承自 `game_object.py` 中的 `GameObject` 基類（而 `GameObject` 又繼承自 `pygame.sprite.Sprite`）。
    * `__init__.py`
    * `bomb.py` (`Bomb` 類別): 定義炸彈的行為，包括計時、爆炸 (`explode`)、火焰蔓延邏輯（基於格子和炸彈威力）。其位置由格子座標決定。
    * `explosion.py` (`Explosion` 類別): 代表炸彈爆炸時產生的單格火焰效果，有持續時間。其位置由格子座標決定。
    * `game_object.py` (`GameObject` 類別): 提供所有遊戲物件共享的基礎屬性（如 `image`, `rect`）和方法。
    * `item.py` (`Item` 基類及各道具子類如 `ScoreItem`, `LifeItem` 等): 定義各種道具及其被玩家拾取時產生的效果 (`apply_effect`)。道具的位置基於格子。道具的生成由 `DestructibleWall` 或 `create_random_item` 函數控制。
    * `player.py` (`Player` 類別): 定義玩家角色（可為人類或AI）。
        * 核心位置由 `tile_x`, `tile_y` (格子座標) 表示。
        * 實現了瞬時格子移動邏輯 (`attempt_move_to_tile(dx, dy)`)，該方法會檢查目標格子的有效性（邊界、牆壁、其他炸彈）。
        * 移動後有短暫的 `action_timer` 控制 `is_moving` 狀態，用於播放行走動畫。人類和 AI 的 `ACTION_ANIMATION_DURATION` 可以分別設定。
        * 人類玩家的持續移動由 `get_input()` (在 `update` 中呼叫，基於 `pygame.key.get_pressed()`) 結合 `action_timer` 實現。
        * 動畫處理 (`_animate`)。
        * 生命與傷害管理 (`take_damage`, `die`)。
        * 炸彈放置 (`place_bomb`) 基於當前格子位置。
    * `wall.py` (`Wall`, `DestructibleWall` 類別): 定義不可破壞的牆壁和可被炸彈摧毀的牆壁。位置基於格子。可破壞牆壁在被摧毀時有一定機率掉落道具。
* **`assets/` 目錄**: 存放所有遊戲資源檔案，如圖片、未來可能加入的音效和字型等。建議按資源類型分子目錄管理。
    * `images/`: 包含所有圖片資源，再按類型細分 (e.g., `player/`, `bomb/`, `items/`, `walls/`)。
* **`requirements.txt`**: 列出專案運行的 Python 依賴套件，主要為 `pygame`。
* **`README.md`**: 本檔案，提供專案的說明和指引。

這種結構使得不同功能的程式碼分離，易於理解、維護和擴展。

## 後續優化與開發方向 (致組員)

以下是針對本專案下一階段的開發建議和可優化方向，希望能幫助組員快速上手並推進專案。目前的版本已經實現了核心的格子移動和基本的AI行為，但仍有很大的打磨和擴展空間。

### 優先任務：提升 AI 智慧與遊戲性

1.  **[核心] 強化 AI 炸牆策略與執行力**：
    * **目標**：讓 AI 更智能、更可靠地透過放置炸彈來清除障礙，以達成其目標（攻擊玩家、獲取道具、或自我解困）。
    * **目前問題**：根據最新日誌，AI 雖然能判斷可以安全放置炸彈並找到逃生路線 (`can_place_bomb_safely_at` 返回 `True`，`find_strategic_wall_to_bomb` 返回有效計畫），但實際放置炸彈的行為仍未穩定出現。
    * **建議行動**：
        * **追蹤執行流程**：重點檢查 AI 進入 `AI_STATE_STRATEGIC_BOMBING_FOR_PATH` 狀態後：
            * `move_along_path` 是否成功將 AI 移動到 `bombing_spot_for_wall`？（需要 `move_along_path` 的詳細日誌）
            * 到達 `bombing_spot_for_wall` 後，`handle_strategic_bombing_for_path_state` 方法中的最終安全檢查 `self.can_place_bomb_safely_at(...)` 是否通過？如果失敗，原因是什麼？（需要該方法內部的詳細日誌）
            * AI 是否有足夠的炸彈 (`self.ai_player.bombs_placed_count < self.ai_player.max_bombs`)？
        * **微調安全參數**：根據日誌反饋，適度調整 `find_safe_tiles_nearby` 中用於判斷逃生目的地和路徑步驟安全的 `future_seconds` 參數。目標是在確保 AI 不會輕易自殺的前提下，提高其炸牆的成功率。
        * **考慮牆壁價值評估**：`find_strategic_wall_to_bomb` 中的 `value` 計算可以更精細，例如，優先炸掉那些能開闢通往高價值目標（玩家、強力道具）的路徑的牆壁，或者能一次炸開多個可破壞物的牆。
        * **引入“進退兩難時的決斷”**：如果 AI 被困很久，或者有一個極高價值的目標被擋住，是否可以設計一個機制，讓 AI 在這種情況下稍微降低對自身安全的絕對要求，以執行關鍵的炸牆行動（高風險高回報）。

2.  **提升 AI 戰術多樣性與反應能力**：
    * **目標**：讓 AI 的行為更難預測，更能適應戰場變化。
    * **建議行動**：
        * **道具使用**：如果未來加入主動使用的道具，需為 AI 設計使用時機。
        * **攻擊策略**：
            * 除了直線追擊，能否利用牆角進行伏擊？
            * 能否預判玩家可能的移動方向來放置預置炸彈？
            * 當玩家被困時，是否能更有效地利用炸彈封鎖玩家？
        * **防禦策略**：
            * 當自身危險時（例如被玩家炸彈困住），除了逃跑，是否有其他選擇（例如，利用自己的炸彈反制，或者尋找並利用地圖上的安全角落）？
            * 對玩家放置的炸彈的反應是否可以更迅速和智能？
        * **狀態切換優化**：檢視 `update_state_machine` 中的狀態優先級和轉換條件，確保其合理性，避免 AI 在某些狀態間不必要地頻繁切換或長時間卡在某個無效的中間狀態。

3.  **完善 AI 的環境感知與互動**：
    * **目標**：讓 AI 更好地理解地圖佈局和場上動態元素。
    * **建議行動**：
        * **火焰鏈反應**：AI 是否應該考慮自己放置的炸彈可能引爆其他炸彈（包括玩家的或其他AI的），從而擴大影響範圍或意外波及自身/目標？
        * **躲避預判**：AI 是否能更精準地預判火焰的蔓延路徑和持續時間，並選擇最佳的躲避路線和時機？
        * **對其他 AI 的感知 (若未來有多AI)**：需要考慮 AI 之間的協同或競爭行為。

### 遊戲體驗與功能擴充

4.  **遊戲選單與設置界面**：
    * 實現一個基本的開始畫面、遊戲模式選擇（目前是人對AI，未來可擴展為人對人、AI對AI）、難度選擇（可調整 AI 的 `ai_decision_interval`、`ACTION_ANIMATION_DURATION` 或其他行為參數）。
    * 考慮加入簡單的遊戲說明或控制提示。

5.  **音效與視覺打磨**：
    * **整合音效**：加入背景音樂、角色移動音效、炸彈放置/爆炸音效、道具拾取音效、受傷音效、遊戲勝利/失敗音效等，以提升遊戲沉浸感。
    * **視覺效果優化**：
        * 優化角色動畫，使其行走、放置炸彈、受傷等動作更平滑自然。
        * 增強爆炸動畫效果，使其更具視覺衝擊力。
        * 道具出現和拾取的視覺提示。

6.  **遊戲內容豐富度**：
    * **多樣化地圖**：設計更多具有不同特色、障礙物佈局和策略記憶點的地圖。可以考慮加入一些特殊的地圖元素（如傳送帶、單向通道等）。
    * **新道具類型**：引入更多種類的道具，例如增加移動速度的鞋子、可以踢炸彈的道具、可以穿牆的幽靈藥水、遙控炸彈、穿透炸彈（可以炸毀一排可破壞物）等，增加遊戲的策略深度和趣味性。

7.  **修正 `Item.apply_effect` 的日誌問題**：
    * 檢查 `Item` 基類及其子類的 `apply_effect` 方法。如果子類已經完整實現了效果且不需要呼叫基類版本，則移除 `super().apply_effect(player)`；或者修改基類的 `apply_effect` 中的 `print` 語句，使其更通用或只在特定情況下打印。

### 程式碼與專案管理

8.  **持續的程式碼註解與文檔化**：
    * 為所有重要模組、類別、方法和複雜邏輯段添加清晰的中文註解，解釋其功能、參數、返回值以及設計思路。
    * 保持 `README.md` 的更新，使其能反映專案的最新狀態和未來的規劃。

9.  **日誌系統優化**：
    * 強烈建議從現在開始使用 Python 內建的 `logging` 模組代替零散的 `print` 語句。`logging` 模組允許：
        * 設定不同的日誌級別 (DEBUG, INFO, WARNING, ERROR, CRITICAL)。
        * 輕鬆控制日誌的輸出格式。
        * 將日誌輸出到檔案或控制台，或兩者皆有。
        * 在發布版本中輕鬆禁用 DEBUG 級別的日誌。
    * 這對於追蹤 AI 行為和排查問題會非常有幫助。

10. **版本控制與協作**：
    * 熟練使用 Git 的基本操作（`clone`, `add`, `commit`, `push`, `pull`, `branch`, `merge`, `tag`）。
    * 撰寫清晰、有意義的 commit message。
    * 對於較大的功能修改或重構，建議新建特性分支 (feature branch) 進行開發，完成後測試無誤再合併回主開發分支 (例如 `main` 或 `develop`)。
    * 定期與組員同步進度，討論遇到的問題和解決方案。

### 長期目標思考

11. **強化學習 AI 接口**：
    * 目前的格子化移動系統為將來引入強化學習 AI 奠定了非常好的基礎。
    * 需要進一步思考：
        * **狀態表示 (State Representation)**：如何將當前的遊戲局面（地圖、自身位置/狀態、敵人位置/狀態、炸彈位置/引爆時間、道具位置等）有效地向量化，作為強化學習模型的輸入。
        * **動作空間 (Action Space)**：AI 可以執行的離散動作集合（上、下、左、右、放置炸彈、未來可能的主動使用道具）。
        * **獎勵函數 (Reward Function)**：如何設計獎勵和懲罰來引導 AI 學習期望的行為（例如，消滅敵人得高分，炸毀牆壁開路得小分，撿到強力道具得中等分，安全躲避炸彈得小分，死亡受重罰等）。

12. **Pygbag 網頁化部署**：
    * 在後續開發中，持續關注資源檔案（圖片、音效、字型）的路徑管理，確保使用相對路徑且與 Pygbag 的打包方式兼容。
    * 避免使用 Pygame 中可能與網頁環境不兼容的特定模組或功能（雖然 Pygbag 的兼容性已經做得不錯）。
